{
  "problem": "\nImplement a thread-safe LRU (Least Recently Used) cache with TTL (Time To Live).\n\nRequirements:\n- Support get(key) and put(key, value) operations\n- Maximum capacity that evicts least recently used items when full\n- Each entry has a TTL; expired entries should not be returned\n- Must be thread-safe for concurrent access\n- O(1) time complexity for both operations\n",
  "direct_code": "import threading\nfrom collections import OrderedDict\nimport time\nfrom datetime import datetime, timedelta\n\nclass LRUCache:\n    def __init__(self, capacity, ttl):\n        self.capacity = capacity\n        self.ttl = ttl\n        self.cache = OrderedDict()\n        self.lock = threading.Lock()\n\n    def _get(self, key):\n        with self.lock:\n            if key in self.cache:\n                value, timestamp = self.cache.pop(key)\n                self.cache[key] = (value, datetime.now())\n                return value\n            return None\n\n    def _put(self, key, value):\n        with self.lock:\n            if key in self.cache:\n                self.cache.pop(key)\n            elif len(self.cache) >= self.capacity:\n                self.cache.popitem(last=False)\n            self.cache[key] = (value, datetime.now())\n\n    def get(self, key):\n        value = self._get(key)\n        if value is not None:\n            return value\n        return None\n\n    def put(self, key, value):\n        self._put(key, value)\n\n    def _evict_expired(self):\n        with self.lock:\n            now = datetime.now()\n            self.cache = {k: v for k, v in self.cache.items() if now - v[1] < self.ttl}\n\n    def _run_evict_expired(self):\n        while True:\n            self._evict_expired()\n            time.sleep(self.ttl.total_seconds())\n\n    def start(self):\n        threading.Thread(target=self._run_evict_expired).start()\n\n    def stop(self):\n        self.lock.acquire()\n        self.cache.clear()\n        self.lock.release()",
  "socratic_code": "import threading\nimport time\nfrom collections import OrderedDict\nfrom datetime import datetime, timedelta\n\nclass LRUCache:\n    def __init__(self, capacity, ttl):\n        self.capacity = capacity\n        self.ttl = ttl\n        self.cache = OrderedDict()\n        self.lock = threading.Lock()\n\n    def get(self, key):\n        with self.lock:\n            if key not in self.cache:\n                return None\n            value, timestamp = self.cache[key]\n            if datetime.now() - timestamp > timedelta(seconds=self.ttl):\n                del self.cache[key]\n                return None\n            self.cache.move_to_end(key)\n            return value\n\n    def put(self, key, value):\n        with self.lock:\n            if key in self.cache:\n                del self.cache[key]\n            elif len(self.cache) >= self.capacity:\n                self.cache.popitem(last=False)\n            self.cache[key] = (value, datetime.now())\n            self.cache.move_to_end(key)\n\n    def clear(self):\n        with self.lock:\n            self.cache.clear()\n\n    def __len__(self):\n        with self.lock:\n            return len(self.cache)\n\n# Example usage:",
  "direct_eval": {
    "complete": true,
    "has_syntax_errors": false,
    "syntax_error": null,
    "edge_case_score": 33.33333333333333,
    "tests_passed": 3,
    "tests_failed": 6,
    "failed_test_names": [
      "Empty input test",
      "Single element test",
      "Boundary values test",
      "Concurrent access test",
      "Invalid input test",
      "Overflow conditions test"
    ]
  },
  "socratic_eval": {
    "complete": true,
    "has_syntax_errors": false,
    "syntax_error": null,
    "edge_case_score": 33.33333333333333,
    "tests_passed": 3,
    "tests_failed": 6,
    "failed_test_names": [
      "Empty input test",
      "Single element test",
      "Boundary values test",
      "Concurrent access test",
      "Invalid input test",
      "Overflow conditions test"
    ]
  },
  "timing": {
    "direct": 0.6994810104370117,
    "plan": 0.9286503791809082,
    "debate": 1.3435413837432861,
    "synthesis": 0.6572887897491455,
    "socratic_total": 2.92948055267334,
    "evaluation": 0.7226524353027344,
    "total": 7.281094551086426
  }
}